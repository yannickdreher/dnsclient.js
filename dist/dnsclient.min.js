/*
 * Project:  dnsclient.js
 * File:     dist/dnsclient.min.js
 * Author:   Yannick Dreher (yannick.dreher@dremaxx.de)
 * -----
 * Created:  Friday, 29th November 2024 3:30:10 pm
 * Modified: Thursday, 10th April 2025 02:13:47 pm
 * -----
 * License: MIT License (https://opensource.org/licenses/MIT)
 * Copyright Â© 2024-2025 Yannick Dreher
 */
export const QR_NAMES=Object.freeze({0:"QUERY",1:"RESPONSE"});export const OPCODE_NAMES=Object.freeze({0:"QUERY",1:"IQUERY",2:"STATUS",3:"RESERVED",4:"NOTIFY",5:"UPDATE",6:"DSO"});export const RCODE_NAMES=Object.freeze({0:"NOERROR",1:"FORMERR",2:"SERVFAIL",3:"NXDOMAIN",4:"NOTIMP",5:"REFUSED",6:"YXDOMAIN",7:"XRRSET",8:"NOTAUTH",9:"NOTZONE",10:"BADVERS",11:"BADSIG",12:"BADKEY",13:"BADTIME",14:"BADMODE",15:"BADNAME",16:"BADALG",17:"BADTRUNC",18:"BADCOOKIE"});export const TYPE_NAMES=Object.freeze({1:"A",2:"NS",3:"MD",4:"MF",5:"CNAME",6:"SOA",7:"MB",8:"MG",9:"MR",10:"NULL",11:"WKS",12:"PTR",13:"HINFO",14:"MINFO",15:"MX",16:"TXT",17:"RP",18:"AFSDB",19:"X25",20:"ISDN",21:"RT",22:"NSAP",23:"NSAP_PTR",24:"SIG",25:"KEY",26:"PX",27:"GPOS",28:"AAAA",29:"LOC",30:"NXT",31:"EID",32:"NIMLOC",33:"SRV",34:"ATMA",35:"NAPTR",36:"KX",37:"CERT",38:"A6",39:"DNAME",40:"SINK",41:"OPT",42:"APL",43:"DS",44:"SSHFP",45:"IPSECKEY",46:"RRSIG",47:"NSEC",48:"DNSKEY",49:"DHCID",50:"NSEC3",51:"NSEC3PARAM",52:"TLSA",53:"SMIMEA",55:"HIP",56:"NINFO",57:"RKEY",58:"TALINK",59:"CDS",60:"CDNSKEY",61:"OPENPGPKEY",62:"CSYNC",63:"ZONEMD",64:"SVCB",65:"HTTPS",99:"SPF",100:"UINFO",101:"UID",102:"GID",103:"UNSPEC",104:"NID",105:"L32",106:"L64",107:"LP",108:"EUI48",109:"EUI64",249:"TKEY",250:"TSIG",251:"IXFR",252:"AXFR",253:"MAILB",254:"MAILA",255:"ANY",256:"URI",257:"CAA",258:"AVC",259:"DOA",260:"AMTRELAY",32768:"TA",32769:"DLV"});export const CLASS_NAMES=Object.freeze({1:"IN",2:"CS",3:"CH",4:"HS",254:"NONE",255:"ANY"});export const TYPE=Object.freeze({A:1,NS:2,CNAME:5,SOA:6,HINFO:13,MX:15,TXT:16,AAAA:28,SRV:33,DS:43,RRSIG:46,NSEC:47,DNSKEY:48,CDS:59,CDNSKEY:60,TSIG:250,ANY:255});export const CLAZZ=Object.freeze({IN:1,CS:2,CH:3,HS:4,NONE:254,ANY:255});export const OPCODE=Object.freeze({QUERY:0,IQUERY:1,STATUS:2,RESERVED:3,NOTIFY:4,UPDATE:5,DSO:6});class Message{id=Math.floor(65536*Math.random());flags={qr:0,opcode:0,aa:0,tc:0,rd:0,ra:0,rcode:0}}export class QueryMessage extends Message{qdcount=0;ancount=0;nscount=0;arcount=0;questions=[];answers=[];authorities=[];additionals=[];constructor(){super(),this.flags.rd=1,this.flags.opcode=OPCODE.QUERY}}export class UpdateMessage extends Message{zcount=0;prcount=0;upcount=0;adcount=0;zones=[];prerequisites=[];updates=[];additionals=[];constructor(){super(),this.flags.opcode=OPCODE.UPDATE}}export class Record{constructor(e,t,i,a=0,r=new Uint8Array(0)){this.name=e,this.type=t,this.clazz=i,this.ttl=a,this.data=r}}export class Question{constructor(e,t=TYPE.ANY,i=CLAZZ.ANY){this.name=e,this.type=t,this.clazz=i}}export class Zone{constructor(e,t=TYPE.SOA,i=CLAZZ.IN){this.name=e,this.type=t,this.clazz=i}}export class DnsSerializer{static deserialize(e){const t=new DataView(e),i=t.getUint16(0),a=this.HeaderFlags.deserialize(t.getUint16(2));let r,n=4;switch(a.opcode){case OPCODE.QUERY:r=new QueryMessage,r.id=i,r.flags=a,r.qdcount=t.getUint16(4),r.ancount=t.getUint16(6),r.nscount=t.getUint16(8),r.arcount=t.getUint16(10),n+=8;for(let e=0;e<r.qdcount;e++){const e=DnsRecordSerializer.deserialize(t,n,!0,!1);n=e.offset,r.questions.push(e.record)}for(let e=0;e<r.ancount;e++){const e=DnsRecordSerializer.deserialize(t,n);n=e.offset,r.answers.push(e.record)}for(let e=0;e<r.nscount;e++){const e=DnsRecordSerializer.deserialize(t,n);n=e.offset,r.authorities.push(e.record)}for(let e=0;e<r.arcount;e++){const e=DnsRecordSerializer.deserialize(t,n);n=e.offset,r.additionals.push(e.record)}return r;case OPCODE.UPDATE:r=new UpdateMessage,r.id=i,r.flags=a,r.zcount=t.getUint16(4),r.prcount=t.getUint16(6),r.upcount=t.getUint16(8),r.adcount=t.getUint16(10),n+=8;for(let e=0;e<r.zcount;e++){const e=DnsRecordSerializer.deserialize(t,n,!1,!0);n=e.offset,r.zones.push(e.record)}for(let e=0;e<r.prcount;e++){const e=DnsRecordSerializer.deserialize(t,n);n=e.offset,r.prerequisites.push(e.record)}for(let e=0;e<r.upcount;e++){const e=DnsRecordSerializer.deserialize(t,n);n=e.offset,r.updates.push(e.record)}for(let e=0;e<r.adcount;e++){const e=DnsRecordSerializer.deserialize(t,n);n=e.offset,r.additionals.push(e.record)}return r}}static serialize(e){let t=new ArrayBuffer(1024),i=new DataView(t),a=0;switch(i.setUint16(a,e.id,!1),a+=2,a=this.HeaderFlags.serialize(i,a,e.flags),e.flags.opcode){case OPCODE.QUERY:if(i.setUint16(a,e.questions.length,!1),a+=2,i.setUint16(a,e.answers.length,!1),a+=2,i.setUint16(a,e.authorities.length,!1),a+=2,i.setUint16(a,e.additionals.length,!1),a+=2,e.questions.length>0)for(const t of e.questions)a=DnsRecordSerializer.serialize(i,a,t);if(e.answers.length>0)for(const t of e.answers)a=DnsRecordSerializer.serialize(i,a,t);if(e.authorities.length>0)for(const t of e.authorities)a=DnsRecordSerializer.serialize(i,a,t);if(e.additionals.length>0)for(const t of e.additionals)a=DnsRecordSerializer.serialize(i,a,t);break;case OPCODE.UPDATE:if(i.setUint16(a,e.zones.length,!1),a+=2,i.setUint16(a,e.prerequisites.length,!1),a+=2,i.setUint16(a,e.updates.length,!1),a+=2,i.setUint16(a,e.additionals.length,!1),a+=2,e.zones.length>0)for(const t of e.zones)a=DnsRecordSerializer.serialize(i,a,t);if(e.prerequisites.length>0)for(const t of e.prerequisites)a=DnsRecordSerializer.serialize(i,a,t);if(e.updates.length>0)for(const t of e.updates)a=DnsRecordSerializer.serialize(i,a,t);if(e.additionals.length>0)for(const t of e.additionals)a=DnsRecordSerializer.serialize(i,a,t)}return new Uint8Array(t.slice(0,a))}static HeaderFlags={deserialize:e=>({qr:e>>15&1,opcode:e>>11&15,aa:e>>10&1,tc:e>>9&1,rd:e>>8&1,ra:e>>7&1,rcode:15&e}),serialize(e,t,i){const a=(1&i.qr)<<15|(15&i.opcode)<<11|(1&i.aa)<<10|(1&i.tc)<<9|(1&i.rd)<<8|(1&i.ra)<<7|15&i.rcode;return e.setUint16(t,a,!1),t+2}}}export class DnsNameSerializer{static deserialize(e,t){let i=[],a=e.getUint8(t),r=!1,n=0,s=t;for(;0!==a;)192&~a?(t++,i.push((new TextDecoder).decode(e.buffer.slice(t,t+a))),t+=a,a=e.getUint8(t)):(r||(n=t+2),t=(63&a)<<8|e.getUint8(t+1),a=e.getUint8(t),r=!0);return r||(n=t+1),{name:i.join("."),offset:n,length:n-s}}static serialize(e){const t=e.split("."),i=t.reduce(((e,t)=>e+t.length+1),0)+1,a=new Uint8Array(i);let r=0;for(let e=0;e<t.length;e++){const i=t[e];a[r]=i.length,r++;for(let e=0;e<i.length;e++)a[r]=i.charCodeAt(e),r++}return a[r]=0,r++,a}}export class DnsRecordSerializer{static deserialize(e,t,i=!1,a=!1){const r=DnsNameSerializer.deserialize(e,t);t=r.offset;const n=e.getUint16(t);t+=2;const s=e.getUint16(t);if(t+=2,i){return{record:new Question(r.name,n,s),offset:t}}if(a){return{record:new Zone(r.name,n,s),offset:t}}const l=e.getUint32(t);t+=4;const o=e.getUint16(t);t+=2;const c=new Record;if(c.name=r.name,c.type=n,c.clazz=s,c.ttl=l,0===o)return{record:c,offset:t};switch(c.type){case TYPE.A:c.data=this.A.deserialize(e,t,o);break;case TYPE.NS:c.data=this.NS.deserialize(e,t);break;case TYPE.CNAME:c.data=this.CNAME.deserialize(e,t);break;case TYPE.SOA:c.data=this.SOA.deserialize(e,t);break;case TYPE.HINFO:c.data=this.HINFO.deserialize(e,t);break;case TYPE.MX:c.data=this.MX.deserialize(e,t);break;case TYPE.AAAA:c.data=this.AAAA.deserialize(e,t,o);break;case TYPE.SRV:c.data=this.SRV.deserialize(e,t);break;case TYPE.DS:c.data=this.DS.deserialize(e,t,o);break;case TYPE.TXT:c.data=this.TXT.deserialize(e,t);break;case TYPE.RRSIG:c.data=this.RRSIG.deserialize(e,t,o);break;case TYPE.NSEC:c.data=this.NSEC.deserialize(e,t,o);break;case TYPE.DNSKEY:c.data=this.DNSKEY.deserialize(e,t,o);break;case TYPE.CDS:c.data=this.DS.deserialize(e,t,o);break;case TYPE.CDNSKEY:c.data=this.DNSKEY.deserialize(e,t,o);break;case TYPE.TSIG:c.data=this.TSIG.deserialize(e,t)}return{record:c,offset:t+=o}}static serialize(e,t,i){if(DnsNameSerializer.serialize(i.name).forEach((i=>e.setUint8(t++,i))),e.setUint16(t,i.type,!1),t+=2,e.setUint16(t,i.clazz,!1),t+=2,i instanceof Question||i instanceof Zone)return t;if(e.setUint32(t,i.ttl,!1),t+=4,void 0===i.data||0===i.data.byteLength)return e.setUint16(t,0,!1),t+=2;let a=new Uint8Array(0);switch(i.type){case TYPE.A:a=this.A.serialize(i.data);break;case TYPE.NS:a=this.NS.serialize(i.data);break;case TYPE.CNAME:a=this.CNAME.serialize(i.data);break;case TYPE.SOA:a=this.SOA.serialize(i.data);break;case TYPE.HINFO:a=this.HINFO.serialize(i.data);break;case TYPE.MX:a=this.MX.serialize(i.data);break;case TYPE.AAAA:a=this.AAAA.serialize(i.data);break;case TYPE.SRV:a=this.SRV.serialize(i.data);break;case TYPE.DS:a=this.DS.serialize(i.data);break;case TYPE.TXT:a=this.TXT.serialize(i.data);break;case TYPE.RRSIG:a=this.RRSIG.serialize(i.data);break;case TYPE.DNSKEY:a=this.DNSKEY.serialize(i.data);break;case TYPE.CDS:a=this.DS.serialize(i.data);break;case TYPE.CDNSKEY:a=this.DNSKEY.serialize(i.data);break;case TYPE.TSIG:a=this.TSIG.serialize(i.data)}return e.setUint16(t,a.byteLength,!1),t+=2,a.forEach((i=>e.setUint8(t++,i))),t}static A={deserialize(e,t,i){if(4!==i)throw new Error("Invalid IPv4 byte array length.");return[{key:"ipv4",value:new Uint8Array(e.buffer.slice(t,t+i)).join(".")}]},serialize(e){const t=e.find((e=>"ipv4"===e.key)).value.split(".").map(Number);return new Uint8Array(t)}};static NS={deserialize:(e,t)=>[{key:"name",value:DnsNameSerializer.deserialize(e,t).name}],serialize(e){const t=e.find((e=>"name"===e.key)).value;return DnsNameSerializer.serialize(t)}};static CNAME={deserialize:(e,t)=>[{key:"name",value:DnsNameSerializer.deserialize(e,t).name}],serialize(e){const t=e.find((e=>"name"===e.key)).value;return DnsNameSerializer.serialize(t)}};static SOA={deserialize(e,t){const i=DnsNameSerializer.deserialize(e,t);t=i.offset;const a=DnsNameSerializer.deserialize(e,t);t=a.offset;const r=e.getUint32(t+0),n=e.getUint32(t+4),s=e.getUint32(t+8),l=e.getUint32(t+12),o=e.getUint32(t+16);return[{key:"mname",value:i.name},{key:"rname",value:a.name},{key:"serial",value:r},{key:"refresh",value:n},{key:"retry",value:s},{key:"expire",value:l},{key:"minimum",value:o}]},serialize(e){const t=e.find((e=>"mname"===e.key)).value,i=DnsNameSerializer.serialize(t),a=e.find((e=>"rname"===e.key)).value,r=DnsNameSerializer.serialize(a),n=i.length+r.length+20,s=new ArrayBuffer(n),l=new DataView(s);let o=0;return i.forEach((e=>l.setUint8(o++,e))),r.forEach((e=>l.setUint8(o++,e))),l.setUint32(o+0,e.find((e=>"serial"===e.key)).value,!1),l.setUint32(o+4,e.find((e=>"refresh"===e.key)).value,!1),l.setUint32(o+8,e.find((e=>"retry"===e.key)).value,!1),l.setUint32(o+12,e.find((e=>"expire"===e.key)).value,!1),l.setUint32(o+16,e.find((e=>"minimum"===e.key)).value,!1),new Uint8Array(s)}};static HINFO={deserialize(e,t){const i=e.getUint8(t);t+=1;const a=(new TextDecoder).decode(e.buffer.slice(t,t+i));t+=i;const r=e.getUint8(t);t+=1;const n=(new TextDecoder).decode(e.buffer.slice(t,t+r));t+=r;return[{key:"cpu",value:a},{key:"os",value:n}]},serialize(e){const t=e.find((e=>"cpu"===e.key)).value,i=e.find((e=>"os"===e.key)).value,a=(new TextEncoder).encode(t),r=(new TextEncoder).encode(i),n=a.length+r.length+2,s=new ArrayBuffer(n),l=new DataView(s);let o=0;return l.setUint8(o,a.length),o++,a.forEach((e=>l.setUint8(o++,e))),l.setUint8(o,r.length),o++,r.forEach((e=>l.setUint8(o++,e))),new Uint8Array(s)}};static MX={deserialize:(e,t)=>[{key:"preference",value:e.getUint16(t)},{key:"exchange",value:DnsNameSerializer.deserialize(e,t+2).name}],serialize(e){const t=e.find((e=>"preference"===e.key)).value,i=e.find((e=>"exchange"===e.key)).value,a=DnsNameSerializer.serialize(i),r=a.length+2,n=new ArrayBuffer(r),s=new DataView(n);let l=0;return s.setUint16(l,t,!1),l+=2,a.forEach((e=>s.setUint8(l++,e))),new Uint8Array(n)}};static AAAA={deserialize(e,t,i){if(16!==i)throw new Error("Invalid IPv6 byte array length.");const a=new Uint8Array(e.buffer.slice(t,t+i)),r=[];for(let e=0;e<16;e+=2){const t=a[e]<<8|a[e+1];r.push(t.toString(16))}return[{key:"ipv6",value:r.join(":").replace(/(^|:)0(:0)*(:|$)/,"$1::$3").replace(/:{3,4}/,"::")}]},serialize(e){const t=e.find((e=>"ipv6"===e.key)).value.split(":"),i=[];let a=!1;for(const e of t)""!==e||a?i.push(e||"0"):(i.push(...Array(8-t.length+1).fill("0")),a=!0);const r=new Uint8Array(16);let n=0;for(const e of i){const t=parseInt(e,16);r[n++]=t>>8&255,r[n++]=255&t}return r}};static SRV={deserialize:(e,t)=>[{key:"priority",value:e.getUint16(t+0)},{key:"weight",value:e.getUint16(t+2)},{key:"port",value:e.getUint16(t+4)},{key:"target",value:DnsNameSerializer.deserialize(e,t+6).name}],serialize(e){const t=e.find((e=>"priority"===e.key)).value,i=e.find((e=>"weight"===e.key)).value,a=e.find((e=>"port"===e.key)).value,r=e.find((e=>"target"===e.key)).value,n=DnsNameSerializer.serialize(r),s=n.length+6,l=new ArrayBuffer(s),o=new DataView(l);let c=0;return o.setUint16(c,t),c+=2,o.setUint16(c,i),c+=2,o.setUint16(c,a),c+=2,n.forEach((e=>o.setUint8(c++,e))),new Uint8Array(l)}};static DS={deserialize(e,t,i){const a=e.getUint16(t);t+=2;const r=e.getUint8(t);t+=1;const n=e.getUint8(t);t+=1;const s=new Uint8Array(e.buffer.slice(t,t+(i-4)));return[{key:"keyTag",value:a},{key:"algorithm",value:r},{key:"digestType",value:n},{key:"digest",value:btoa(String.fromCharCode(...s))}]},serialize(e){const t=e.find((e=>"keyTag"===e.key)).value,i=e.find((e=>"algorithm"===e.key)).value,a=e.find((e=>"digestType"===e.key)).value,r=e.find((e=>"digest"===e.key)).value,n=Uint8Array.from(atob(r),(e=>e.charCodeAt(0))),s=n.length+4,l=new ArrayBuffer(s),o=new DataView(l);let c=0;return o.setUint16(c,t),c+=2,o.setUint8(c,i),c++,o.setUint8(c,a),c++,n.forEach((e=>o.setUint8(c++,e))),new Uint8Array(l)}};static TXT={deserialize(e,t){const i=e.getUint8(t);return[{key:"text",value:(new TextDecoder).decode(e.buffer.slice(t+1,t+1+i))}]},serialize(e){const t=e.find((e=>"text"===e.key)).value,i=(new TextEncoder).encode(t),a=i.length+1,r=new ArrayBuffer(a),n=new DataView(r);let s=0;return n.setUint8(s,i.length),s++,i.forEach((e=>n.setUint8(s++,e))),new Uint8Array(r)}};static RRSIG={deserialize(e,t,i){const a=TYPE_NAMES[e.getUint16(t)],r=e.getUint8(t+2),n=e.getUint8(t+3),s=e.getUint32(t+4),l=e.getUint32(t+8),o=e.getUint32(t+12),c=e.getUint16(t+16),d=DnsNameSerializer.deserialize(e,t+18),u=e.buffer.slice(d.offset,t+i),f=btoa(String.fromCharCode(...new Uint8Array(u)));return[{key:"typeCovered",value:a},{key:"algorithm",value:r},{key:"labels",value:n},{key:"originalTtl",value:s},{key:"expiration",value:new Date(1e3*l)},{key:"inception",value:new Date(1e3*o)},{key:"keyTag",value:c},{key:"signersName",value:d.name},{key:"signature",value:f}]},serialize(e){const t=e.find((e=>"typeCovered"===e.key)).value,i=e.find((e=>"algorithm"===e.key)).value,a=e.find((e=>"labels"===e.key)).value,r=e.find((e=>"originalTtl"===e.key)).value,n=Math.floor(e.find((e=>"expiration"===e.key)).value.getTime()/1e3),s=Math.floor(e.find((e=>"inception"===e.key)).value.getTime()/1e3),l=e.find((e=>"keyTag"===e.key)).value,o=e.find((e=>"signersName"===e.key)).value,c=e.find((e=>"signature"===e.key)).value,d=DnsNameSerializer.serialize(o),u=atob(c).split("").map((e=>e.charCodeAt(0))),f=d.length+u.length+18,h=new ArrayBuffer(f),U=new DataView(h);let z=0;return U.setUint16(z,t),z+=2,U.setUint8(z,i),z+=1,U.setUint8(z,a),z+=1,U.setUint32(z,r),z+=4,U.setUint32(z,n),z+=4,U.setUint32(z,s),z+=4,U.setUint16(z,l),z+=2,d.forEach((e=>U.setUint8(z++,e))),u.forEach((e=>U.setUint8(z++,e))),new Uint8Array(h)}};static NSEC={deserialize(e,t,i){const a=DnsNameSerializer.deserialize(e,t),r=(t+=a.length)+(i-a.length),n=[];for(;t<r;){const i=e.getUint8(t++),a=e.getUint8(t++);for(let r=0;r<a;r++){const a=e.getUint8(t++);for(let e=0;e<8;e++)if(a&1<<7-e){const t=256*i+8*r+e;n.push(TYPE_NAMES[t])}}}return[{key:"nextDomain",value:a.name},{key:"typeBitmaps",value:n}]}};static DNSKEY={deserialize(e,t,i){let a=e.getUint16(t);switch(t+=2,a){case 256:a="ZSK";break;case 257:a="KSK";break;default:a="unknown"}const r=e.getUint8(t);t+=1;const n=e.getUint8(t);t+=1;const s=new Uint8Array(e.buffer.slice(t,t+(i-4)));return[{key:"flag",value:a},{key:"protocol",value:r},{key:"algorithm",value:n},{key:"publickey",value:btoa(String.fromCharCode(...s))}]},serialize(e){const t="ZSK"===e.find((e=>"flag"===e.key)).value?256:257,i=e.find((e=>"protocol"===e.key)).value,a=e.find((e=>"algorithm"===e.key)).value,r=e.find((e=>"publickey"===e.key)).value,n=new Uint8Array(atob(r).split("").map((e=>e.charCodeAt(0)))),s=n.length+4,l=new ArrayBuffer(s),o=new DataView(l);let c=0;return o.setUint16(c,t,!1),c+=2,o.setUint8(c,i),c+=1,o.setUint8(c,a),c+=1,n.forEach((e=>o.setUint8(c++,e))),new Uint8Array(l)}};static TSIG={deserialize(e,t){let i=t,a={};const r=DnsNameSerializer.deserialize(e,t);a.algorithm=r.name,i=r.offset;const n=e.getUint16(i),s=e.getUint32(i+2);a.timestamp=BigInt(n)<<32n|BigInt(s),i+=6,a.fudge=e.getUint16(i),i+=2;const l=e.getUint16(i);i+=2,a.mac=new Uint8Array(e.buffer.slice(i,i+l)),i+=l,a.originalId=e.getUint16(i),i+=2,a.error=e.getUint16(i),i+=2;const o=e.getUint16(i);return i+=2,a.otherData=new Uint8Array(e.buffer.slice(i,i+o)),i+=o,a},serialize(e){const t=DnsNameSerializer.serialize(e.algorithm),i=Number(e.timestamp>>32n&0xFFFFn),a=Number(0xFFFFFFFFn&e.timestamp);let r=t.length+e.mac.length+e.otherData.length;e.mac.byteLength>0?r+=16:r+=14;const n=new ArrayBuffer(r),s=new DataView(n);let l=0;return t.forEach((e=>s.setUint8(l++,e))),s.setUint16(l,i),l+=2,s.setUint32(l,a),l+=4,s.setUint16(l,e.fudge),l+=2,e.mac.byteLength>0&&(s.setUint16(l,e.mac.byteLength),l+=2,e.mac.forEach((e=>s.setUint8(l++,e)))),s.setUint16(l,e.originalId),l+=2,s.setUint16(l,e.error),l+=2,s.setUint16(l,e.otherData.byteLength),l+=2,e.otherData.forEach((e=>s.setUint8(l++,e))),new Uint8Array(n)}}}export async function sign(e,t,i){const a=new Record(t,TYPE.TSIG,CLAZZ.ANY,0,{algorithm:"hmac-sha256",timestamp:BigInt(Math.floor(Date.now()/1e3)),fudge:300,mac:new Uint8Array(0),originalId:e.id,error:0,otherData:new Uint8Array(0)}),r=DnsSerializer.serialize(e),n=DnsNameSerializer.serialize(t),s=DnsNameSerializer.serialize(a.data.algorithm),l=Number(a.data.timestamp>>32n&0xFFFFn),o=Number(0xFFFFFFFFn&a.data.timestamp),c=Uint8Array.from(atob(i),(e=>e.charCodeAt(0)));let d=r.byteLength+n.byteLength+s.byteLength+18;const u=new ArrayBuffer(d),f=new DataView(u);let h=0;r.forEach((e=>f.setUint8(h++,e))),n.forEach((e=>f.setUint8(h++,e))),f.setUint16(h,a.clazz,!1),h+=2,f.setUint32(h,a.ttl,!1),h+=4,s.forEach((e=>f.setUint8(h++,e))),f.setUint16(h,l),h+=2,f.setUint32(h,o),h+=4,f.setUint16(h,a.data.fudge),h+=2,f.setUint16(h,a.data.originalId),h+=2,f.setUint16(h,a.data.error),h+=2,f.setUint16(h,a.data.otherData.byteLength),h+=2,a.data.otherData.forEach((e=>f.setUint8(h++,e)));const U=await crypto.subtle.importKey("raw",c,{name:"HMAC",hash:"SHA-256"},!1,["sign"]),z=await crypto.subtle.sign("HMAC",U,u);return a.data.mac=new Uint8Array(z),e.additionals.push(a),e.adcount=e.additionals.length,e}export async function query(e,t){let i="";const a=DnsSerializer.serialize(t),r=performance.now(),n=await fetch(e,{method:"POST",headers:{"Content-Type":"application/dns-message"},body:a}),s=performance.now();if(!n.ok)throw new Error(`DNS query request failed with status: ${n.status} - ${n.statusText}`);{const e=await n.arrayBuffer();i=DnsSerializer.deserialize(e)}return{result:i,latency:Math.round(s-r)}}
